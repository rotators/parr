cmake_minimum_required( VERSION 3.18.4 FATAL_ERROR )
include_guard()
##
## CTestRunner
##
#
## Directory structure
#
# Test/
#   my-program/          <- name of the target
#     my-test.txt        <- test file
#     my-test.WILL_FAIL  <- (optional) one of test configuration files
#   CMakeLists.txt       <- ctest_runner( my-program "-f @filename@" "txt" )
#
## Command line modification
#
# <test_file>.COMMAND_LINE
#   if exists, <test_file>.COMMAND_LINE_BEFORE and <test_file>.COMMAND_LINE_AFTER are ignored
#
# <test_file>.COMMAND_LINE_BEFORE
#   ignored if <test_file>.COMMAND_LINE exists
#
# <test_file>.COMMAND_LINE_AFTER
#   ignored if <test_file>.COMMAND_LINE exists
#
## Test properties
## Allows setting selected CMake test properties
## https://cmake.org/cmake/help/v3.18/manual/cmake-properties.7.html#properties-on-tests
#
# <test_file>.DISABLED
#   see https://cmake.org/cmake/help/v3.18/prop_test/DISABLED.html
# <test_file>.WILL_FAIL
#   see https://cmake.org/cmake/help/v3.18/prop_test/WILL_FAIL.html
#
## Custom groups
#
# .GROUP
# <test_file>.GROUP
#   if both files are present, only <test_file>.GROUP is used
#   see https://cmake.org/cmake/help/v3.18/prop_test/LABELS.html
#

# Global variable: CTestRunner.Config
#   Disabled
#   SkipDependencies
set( CTestRunner.ConfigOptions Disabled SkipDependencies )
foreach( option IN LISTS CTestRunner.Config )
    if( NOT option IN_LIST CTestRunner.ConfigOptions )
        list( JOIN CTestRunner.ConfigOptions ", " tmp )
        message( FATAL_ERROR "Unknown CTestRuner.Config option\noption = \"${option}\"\nAll known options: ${tmp}" )
        return()
    endif()
    string( REGEX REPLACE "([A-Z])" " \\1" tmp "${option}" )
    string( TOLOWER "${tmp}" tmp )
    string( STRIP "${tmp}" tmp )
    message( STATUS "Configuring CTestRunner... ${tmp}" )
endforeach()
unset( CTestRunner.ConfigOptions )

# Global variable: CTestRunner.FunctionName
# allows to change main function name, which also changes prefix for generated targets
# name validation is pretty strict as it must follow CMake's 'cmListFileLexer_Token_Identifier'
# or function will be impossible (?) to use without cmake_language(CALL)
if( NOT CTestRunner.FunctionName )
    set( CTestRunner.FunctionName "ctest_runner" )
elseif( NOT "${CTestRunner.FunctionName}" MATCHES "^[A-Za-z][A-Za-z0-9_]*$" )
    message( FATAL_ERROR "Global variable invalid\nCTestRunner.FunctionName = '${CTestRunner.FunctionName}'" )
    return()
else()
    message( STATUS "Configuring CTestRunner... function: ${CTestRunner.FunctionName}()" )
endif()

function( ${CTestRunner.FunctionName} target command_line extension ... )
    set( this "${CMAKE_CURRENT_FUNCTION}" )

    # check if target is valid
    if( NOT TARGET ${target} )
        message( AUTHOR_WARNING "Target does not exist, ignored\ntarget = \"${target}\"" )
        return()
    endif()

    get_property( target_type TARGET ${target} PROPERTY TYPE )
    if( NOT "${target_type}" STREQUAL "EXECUTABLE" )
        message( AUTHOR_WARNING "Target is not execuatable, ignored\ntarget = \"${target}\"\ntype = \"${target_type}\"" )
        return()
    endif()

    # check if enable_testing() was used
    set( skip " (skipped)" )
    if( CMAKE_TESTING_ENABLED AND NOT "Disabled" IN_LIST CTestRunner.Config )
        unset( skip )
        if( CMAKE_VERSION VERSION_GREATER_EQUAL 3.19 )
            cmake_language( DEFER CALL ${this}.postconfig )
        endif()
    endif()

    message( STATUS "Configuring tests: ${target}${skip}" )
    if( NOT CMAKE_TESTING_ENABLED OR "Disabled" IN_LIST CTestRunner.Config )
        return()
    endif()

    cmake_parse_arguments( PARSE_ARGV 3 arg "" "GROUP" "ADD_GLOB" )

    # test configuration files extensions
    set( test_config_edit COMMAND_LINE COMMAND_LINE_BEFORE COMMAND_LINE_AFTER GROUP )
    set( test_config_copy DISABLED WILL_FAIL )
    set( test_config_dir  GROUP )

    # search for test files
    list( PREPEND arg_ADD_GLOB "${target}/*.${extension}" )
    foreach( find_glob IN LISTS arg_ADD_GLOB )
        cmake_language( CALL ${this}.debug "TEST" "Find test files... ${find_glob}" )

        file( GLOB_RECURSE found_tmp LIST_DIRECTORIES false FOLLOW_SYMLINKS RELATIVE "${CMAKE_CURRENT_LIST_DIR}" CONFIGURE_DEPENDS "${find_glob}" )
        if( found_tmp )
            list( APPEND found_tests "${found_tmp}" )
        endif()

        # search for test configuration files
        # while not used directly, they're added to autogenerated VerifyGlobs.cmake
        get_filename_component( find_glob "${find_glob}" DIRECTORY )
        foreach( tmp IN LISTS test_config_edit test_config_copy )
            cmake_language( CALL ${this}.debug "TEST" "- Find test config... ${find_glob}/*.${tmp}" )

            file( GLOB_RECURSE tmp LIST_DIRECTORIES false FOLLOW_SYMLINKS RELATIVE "${CMAKE_CURRENT_LIST_DIR}" CONFIGURE_DEPENDS "${find_glob}/*.${tmp}" )
            unset( tmp )
        endforeach()
        foreach( tmp IN LISTS test_config_dir )
            cmake_language( CALL ${this}.debug "TEST" "- Find test config... ${find_glob}/.${tmp}" )

            file( GLOB_RECURSE tmp LIST_DIRECTORIES false FOLLOW_SYMLINKS RELATIVE "${CMAKE_CURRENT_LIST_DIR}" CONFIGURE_DEPENDS "${find_glob}/.${tmp}" )
            unset( tmp )
        endforeach()
    endforeach()
    list( REMOVE_DUPLICATES found_tests )
    list( SORT found_tests )

    # the big loop
    foreach( test_file IN LISTS found_tests )
        get_filename_component( test_file_dir "${test_file}" DIRECTORY )
        get_filename_component( test_file_wle "${test_file}" NAME_WLE )
        get_filename_component( test_file_ext "${test_file}" LAST_EXT )
        string( REPLACE "." "" test_file_ext "${test_file_ext}" )
        set( test_path_ext   "${CMAKE_CURRENT_LIST_DIR}/${test_file}" )
        set( test_path_noext "${CMAKE_CURRENT_LIST_DIR}/${test_file_dir}/${test_file_wle}" )
        set( test_path_dir   "${CMAKE_CURRENT_LIST_DIR}/${test_file_dir}" )

        # test name is set as relative path without extension, with target name as prefix
        # allows adding same test file to multiple targets
        set( test_name "${target}::${test_file_dir}/${test_file_wle}" )

        cmake_language( CALL ${this}.debug "TEST" "Add test... ${test_name}" )
        cmake_language( CALL ${this}.debug "TEST" "- test_file:        ${test_file}" )
        cmake_language( CALL ${this}.debug "TEST" "- test_file_dir     ${test_file_dir}" )
        cmake_language( CALL ${this}.debug "TEST" "- test_file_wle     ${test_file_wle}" )
        cmake_language( CALL ${this}.debug "TEST" "- test_file_ext     ${test_file_ext}" )
        cmake_language( CALL ${this}.debug "TEST" "- test_path_ext     ${test_path_ext}" )
        cmake_language( CALL ${this}.debug "TEST" "- test_path_noext   ${test_path_noext}" )
        cmake_language( CALL ${this}.debug "TEST" "- test_path_dir     ${test_path_dir}" )

        unset( test_used_files )
        list( APPEND test_used_files "${test_path_ext}" )

        set( test_command_line "${command_line}" )
        unset( test_command_line_before )
        unset( test_command_line_after )
        unset( test_used_files.command-line )
        if( EXISTS "${test_path_noext}.COMMAND_LINE" )
            file( READ "${test_path_noext}.COMMAND_LINE" test_command_line )

            list( APPEND test_used_files  "${test_path_noext}.COMMAND_LINE" )
            list( APPEND test_used_files.command-line "${test_path_noext}.COMMAND_LINE" )
        else()
            if( EXISTS "${test_path_noext}.COMMAND_LINE_BEFORE" )
                file( READ "${test_path_noext}.COMMAND_LINE_BEFORE" test_command_line_before )

                list( APPEND test_used_files "${test_path_noext}.COMMAND_LINE_BEFORE" )
                list( APPEND test_used_files.command-line "${test_path_noext}.COMMAND_LINE_BEFORE" )
            endif()

            if( EXISTS "${test_path_noext}.COMMAND_LINE_AFTER" )
                file( READ "${test_path_noext}.COMMAND_LINE" test_command_line_after )

                list( APPEND test_used_files "${test_path_noext}.COMMAND_LINE_AFTER" )
                list( APPEND test_used_files.command-line "${test_path_noext}.COMMAND_LINE_BEFORE" )
            endif()
        endif()

        # replace command line placeholders with real values
        foreach( var IN ITEMS test_command_line test_command_line_before test_command_line_after )
            string( REPLACE "@filename@" "${test_path_ext}" ${var} "${${var}}" )
        endforeach()
        string( STRIP "${test_command_line_before} ${test_command_line} ${test_command_line_after}" test_command_line_full )

        if( test_used_files.command-line )
            cmake_language( CALL ${this}.debug "TEST" "- command line      ${test_command_line_full}" )
        endif()

        # [cmakepp] parses the command line string into parts (handling strings and semicolons)
        # https://github.com/toeb/cmakepp/blob/master/cmake/core/parse_command_line.cmake
        string( ASCII 31 tmp )
        string( REPLACE "\;" "${tmp}" tmp "${test_command_line_full}" )
        string( REGEX MATCHALL "((\\\"[^\\\"]*\\\")|[^ ]+)" tmp "${tmp}")
        string( REGEX REPLACE "(^\\\")|(\\\"$)" "" tmp "${tmp}")
        string( REGEX REPLACE "(;\\\")|(\\\";)" ";" tmp "${tmp}")
        string( REPLACE "\\" "/" test_command_line_full "${tmp}")

        # all created tests have multiple labels set during processing, in two available formats
        #  <ctest_runner_function_name>::<target_name>  primary label
        #  <ctest_runner_function_name>:<name>          secondary label
        # primary labels are set for *all* project targets processed by this function
        #                set for all generated tests
        # secondary label allows
        #                set only if current test is enabled
        add_test( NAME "${test_name}" COMMAND  "$<TARGET_FILE:${target}>" ${test_command_line_full} )
        cmake_language( CALL ${this}.label "${test_name}" ":${target}" )

        # cmake properties : DISABLED WILL_FAIL
        foreach( property IN LISTS test_config_copy )
            if( EXISTS "${test_path_noext}.${property}" )
                cmake_language( CALL ${this}.debug "TEST" "- property          ${property} = TRUE" )
                set_property( TEST "${test_name}" PROPERTY ${property} TRUE )

                list( APPEND test_used_files   "${test_path_noext}.${property}" )
                if( "${property}" STREQUAL "DISABLED" )
                    break()
                endif()
            endif()
        endforeach( property )
        get_test_property( "${test_name}" DISABLED test_disabled )

        if( test_disabled )
            continue()
        endif()

        # cmake properties : LABELS
        unset( test_group_name )
        unset( test_group_file )
        foreach( file IN ITEMS "${test_path_dir}/.GROUP" "${test_path_noext}.GROUP" )
            if( EXISTS "${file}" )
                file( READ "${file}" test_group )
                if( test_group MATCHES "^[a-z0-9\\-]+$" )
                    set( test_group_name "${test_group}" )
                    set( test_group_file "${file}" )
                else()
                    message( AUTHOR_WARNING "Invalid group name, ignored\nGROUP = \"${test_group}\"\nfile = ${file}" )
                endif()
            endif()
        endforeach()

        list( APPEND test_used_files   "${test_group_file}" )
        list( APPEND test_used_files   "${test_status_file}" )
        list( APPEND target_used_files "${test_used_files}" )
        list( SORT test_used_files )
        foreach( file IN LISTS test_used_files )
            cmake_language( CALL ${this}.debug "TEST" "- test_used_files   ${file}" )
        endforeach()

        # disabled tests cannot generate labels or targets,
        # but they're still included in run.* targets
        if( test_disabled )
            continue()
        endif()

        get_test_property( "${test_name}" WILL_FAIL test_status )
        if( test_status )
            set( test_status "fail")
            set( test_status_file "${test_path_noext}.WILL_FAIL" )
        else()
            set( test_status "pass")
            unset( test_status_file )
        endif()

        cmake_language( CALL ${this}.label "${test_name}" "must-${test_status}" )
        set( help_pass "Run tests which must return EXIT_SUCCESS to pass" )
        set( help_fail "Run tests which must return EXIT_FAILURE to pass" )
        cmake_language( CALL ${this}.target only.must-${test_status}
            CTEST --label-regex ^${this}:must-${test_status}$
            HELP_TEXT "${help_${test_status}}"
            HELP_LIST "GENERIC"
            ADD_ONCE
            ADD_DEPENDENCY ${target}
        )

        #

        if( test_used_files.command-line )
            cmake_language( CALL ${this}.label "${test_name}" "command-line" )
            cmake_language( CALL ${this}.target only.command-line
                CTEST --label-regex ^${this}:command-line$
                HELP_TEXT "Run enabled tests with change command line arguments"
                HELP_LIST "USER"
                ADD_ONCE
                ADD_DEPENDENCY ${target}
            )
        endif()

        cmake_language( CALL ${this}.label "${test_name}" "extension:${test_file_ext}" )
        cmake_language( CALL ${this}.target only.extension.${test_file_ext}
            CTEST --label-regex ^${this}:extension:${test_file_ext}$
            HELP_TEXT "Run enabled tests which use .${test_file_ext} files as input"
            HELP_LIST "GENERIC"
            ADD_ONCE
            ADD_DEPENDENCY ${target}
        )

        if( test_group_name AND test_group_file )
            cmake_language( CALL ${this}.label "${test_name}" "group:${test_group_name}" )
            cmake_language( CALL ${this}.target only.group.${test_group_name}
                ADD_DEPENDENCY ${target}
                CTEST --label-regex ^${this}:group:${test_group_name}$
                HELP_TEXT "Run enabled tests with group '${test_group_name}'"
                HELP_LIST "USER"
                ADD_ONCE
                ADD_DEPENDENCY ${target}
            )
        endif()
    endforeach( test_file )

    if( NOT target_used_files )
        return()
    endif()

    cmake_language( CALL ${this}.data LIST EXECUTABLES "${target}" )

    list( SORT target_used_files )
    list( REMOVE_DUPLICATES target_used_files )
    cmake_language( CALL ${this}.debug "TEST" "Add test target...  ${this}.run.${target}" )
    foreach( file IN LISTS target_used_files )
        cmake_language( CALL ${this}.debug "TEST" "- target_used_files ${file}" )
    endforeach()

    # default runner, includes all tests found
    cmake_language( CALL ${this}.target run.all
        CTEST --label-regex ^${this}::
        HELP_TEXT "Run all tests found by ${this}() function"
        HELP_LIST "RUN"
        ADD_ONCE
        ADD_DEPENDENCY ${target}
        ADD_SOURCES    ${target_used_files}
    )

    # project target, runs all tests added in current function call
    cmake_language( CALL ${this}.target run.${target}
        CTEST --label-regex ^${this}::${target}$
        HELP_TEXT "Run all tests attached to executable target '${target}'"
        HELP_LIST "RUN"
        ADD_ONCE
        ADD_DEPENDENCY ${target}
        ADD_SOURCES    ${target_used_files}
    )

    # TODO
    source_group( TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${found_tests} )
    source_group( "CMake"     REGULAR_EXPRESSION "[Cc][Mm][Aa][Kk][Ee]" )
endfunction()

function( ${CTestRunner.FunctionName}.debug type message )
    string( REGEX REPLACE "\\.[a-z]+$" "" this "${CMAKE_CURRENT_FUNCTION}" )

    set( file_show "${PROJECT_BINARY_DIR}/${this}.DEBUG_SHOW" )
    set( file_save "${PROJECT_BINARY_DIR}/${this}.DEBUG_SAVE" )
    set( file_data "${PROJECT_BINARY_DIR}/${this}.${type}.txt" )

    if( type MATCHES "^([A-Z]+)$" )
        string( APPEND file_show ".${CMAKE_MATCH_1}" )
        string( APPEND file_save ".${CMAKE_MATCH_1}" )
    else()
        message( FATAL_ERROR "Invalid debug type\n'${type}'" )
        return()
    endif()

    if( EXISTS "${file_show}" )
        message( STATUS "${message}" )
    endif()

    if( EXISTS "${file_save}" )
        cmake_language( CALL ${this}.data GET DEBUG_CHECK check )
        if( NOT "${type}" IN_LIST check )
            file( GLOB ignored LIST_DIRECTORIES false FOLLOW_SYMLINKS RELATIVE "${PROJECT_BINARY_DIR}" CONFIGURE_DEPENDS "${PROJECT_BINARY_DIR}/*.DEBUG_SHOW.*" )
            file( GLOB ignored LIST_DIRECTORIES false FOLLOW_SYMLINKS RELATIVE "${PROJECT_BINARY_DIR}" CONFIGURE_DEPENDS "${PROJECT_BINARY_DIR}/*.DEBUG_SAVE.*" )

            cmake_language( CALL ${this}.data LIST DEBUG_CHECK "${type}" )
            file( REMOVE "${file_data}" )
        endif()
        file( APPEND "${file_data}" "${message}\n" )
    endif()
endfunction()

function( ${CTestRunner.FunctionName}.postconfig )
    string( REGEX REPLACE "\\.[a-z]+$" "" this "${CMAKE_CURRENT_FUNCTION}" )

    if( TARGET ${this}.help )
        return()
    endif()

    message( STATUS "Configuring tests runner" )

    # prepare overengineered help target
    cmake_language( CALL ${this}.target help
        COMMAND_FILE_SYMBOLIC
        HELP_TEXT "Display tests runner targets descriptions"
        HELP_LIST "SHOW"
    )

    #cmake_language( CALL ${this}.data LIST:NO_SORT HELP_HEAD_AUTO    "Targets running selected subset of tests" )
    #cmake_language( CALL ${this}.data LIST:NO_SORT HELP_HEAD_AUTO    "Generated automagically" )

    cmake_language( CALL ${this}.data LIST:NO_SORT HELP_HEAD_GENERIC "Generic targets" )
    cmake_language( CALL ${this}.data LIST:NO_SORT HELP_HEAD_GENERIC "Generated automagically" )

    cmake_language( CALL ${this}.data LIST:NO_SORT HELP_HEAD_GHA     "GitHub Actions targets" )

    cmake_language( CALL ${this}.data LIST:NO_SORT HELP_HEAD_RUN     "Executable targets" )

    cmake_language( CALL ${this}.data LIST:NO_SORT HELP_HEAD_OTHER   "Other targets" )

    cmake_language( CALL ${this}.data LIST:NO_SORT HELP_HEAD_SHOW    "Targets displaying various info" )

    cmake_language( CALL ${this}.data LIST:NO_SORT HELP_HEAD_USER    "User targets" )
    cmake_language( CALL ${this}.data LIST:NO_SORT HELP_HEAD_USER    "Generated only when using customization features" )

    cmake_language( CALL ${this}.data LIST:NO_SORT HELP_DEFAULT OTHER )
    cmake_language( CALL ${this}.data LIST:NO_SORT HELP_ORDER RUN )
    cmake_language( CALL ${this}.data LIST:NO_SORT HELP_ORDER USER )
    #cmake_language( CALL ${this}.data LIST:NO_SORT HELP_ORDER AUTO )
    cmake_language( CALL ${this}.data LIST:NO_SORT HELP_ORDER GENERIC )
    cmake_language( CALL ${this}.data LIST:NO_SORT HELP_ORDER GHA )
    cmake_language( CALL ${this}.data LIST:NO_SORT HELP_ORDER SHOW )
    cmake_language( CALL ${this}.data LIST:NO_SORT HELP_ORDER OTHER )

    string( LENGTH "${this}" this_length )
    math( EXPR this_length "${this_length} + 1" )

    #
    cmake_language( CALL ${this}.data GET EXECUTABLES data )
    if( data )
        list( TRANSFORM data PREPEND "  " )
        list( PREPEND data "All executable targets handled by ${this}()" )

        cmake_language( CALL ${this}.target show.executables
            COMMAND_FILE_ECHO_LIST ${data}
            HELP_TEXT "Print all executable targets handled by ${this}()"
            HELP_LIST "SHOW"
        )
    endif()

    #
    cmake_language( CALL ${this}.data GET LABELS data )
    if( data )
        list( TRANSFORM data PREPEND "  " )
        list( PREPEND data "All ctest labels created by ${this}()" )

        cmake_language( CALL ${this}.target show.labels COMMAND_FILE_ECHO_LIST ${data} )
    endif()

    # gha matrix
    cmake_language( CALL ${this}.data GET TARGETS data.full )
    if( data.full )
        list( APPEND help.full "Generate matrix using all targets" )
        list( FILTER data.full INCLUDE REGEX "\\.(run|only)\\." )
        list( FILTER data.full EXCLUDE REGEX "\\.run\\.all$" )

        list( APPEND help.skip-executables "Generate matrix using only non-executable targets" )
        list( APPEND data.skip-executables ${data.full} )
        list( FILTER data.skip-executables INCLUDE REGEX "\\.only\\." )

        list( APPEND help.executables "Generate matrix using only executable targets" )
        list( APPEND data.executables ${data.full} )
        list( FILTER data.executables INCLUDE REGEX "\\.run\\." )

        foreach( suffix IN ITEMS skip-executables executables full )
            unset( json )
            foreach( target IN LISTS data.${suffix} )
                string( SUBSTRING "${target}" ${this_length} -1 job_name )
                if( "${suffix}" STREQUAL "executables" )
                    string( REGEX REPLACE "^run\\." "" job_name "${job_name}" )
                else()
                    string( REGEX REPLACE "^run\\." "executable." job_name "${job_name}" )
                endif()
                string( REPLACE "." " / " job_name "${job_name}" )
                list( APPEND json "{ 'job-name': '${job_name}', 'job-target': '${target}' }" )
            endforeach()

            string( REPLACE ";" ", " json "${json}" )
            string( REPLACE "'" "\"" json "${json}" )
            if( "${suffix}" STREQUAL "skip-executables" )
                unset( dot_suffix )
            else()
                set( dot_suffix ".${suffix}")
            endif()
            cmake_language( CALL ${this}.target gha.matrix${dot_suffix}
                CMAKE -E echo "  [${json}]"
                HELP_TEXT "${help.${suffix}}"
                HELP_LIST "GHA"
            )
        endforeach()
    endif()

    #
    if( CMAKE_BUILD_TYPE )
        set( check_config "${CMAKE_BUILD_TYPE}" )
    else()
        set( check_config "Release" )
    endif()
    cmake_language( CALL ${this}.target check
        COMMAND_FILE_SYMBOLIC "${CMAKE_COMMAND}" -E echo "#> Checking target: ${target}"
        HELP_TEXT "Check tests runner integrity;all by one (internal use)"
        HELP_LIST "OTHER"
    )

    #
    cmake_language( CALL ${this}.data GET TARGETS targets )
    foreach( target IN LISTS targets )
        cmake_language( CALL ${this}.data GET HELP_SKIP help_skip )
        if( target IN_LIST help_skip )
            cmake_language( CALL ${this}.debug "DEFAULT" "Help generation skip... ${target}" )
            continue()
        endif()

        cmake_language( CALL ${this}.data GET TARGETS_MAX_LENGTH targets_max_length )
        string( LENGTH "${target}" target_length )
        math( EXPR target_dots   "3 + ${targets_max_length} - ${target_length}" )
        math( EXPR target_spaces "5 + ${targets_max_length}" )
        string( REPEAT "." ${target_dots} target_dots )
        string( REPEAT "\ " ${target_spaces} target_spaces )

        get_property( help_text TARGET ${target} PROPERTY ${this}.HELP_TEXT )
        get_property( help_list TARGET ${target} PROPERTY ${this}.HELP_LIST )

        # validate HELP_LIST property
        if( help_list )
            cmake_language( CALL ${this}.data GET HELP_ORDER help_order )
            if( NOT help_list IN_LIST help_order )
                list( JOIN help_order ", " help_order )
                message( AUTHOR_WARNING "Target property HELP_LIST prevents displaying target descripton\ntarget = \"${target}\"\nHELP_LIST = ${help_list}\nHELP_ORDER = ${help_order}" )
                cmake_language( CALL ${this}.data LIST HELP_UNHANDLED "${help_list}:${target}" )
            endif()
        else()
            cmake_language( CALL ${this}.data GET HELP_DEFAULT help_list )
            message( AUTHOR_WARNING "Target property HELP_LIST not set, using default value ('${help_list}')\ntarget = \"${target}\"" )
        endif()

        # prepare HELP_TEXT_<list> property
        # needs to be added without sorting to allow multi-line description
        if( help_text )
            set( first TRUE )
            foreach( line IN LISTS help_text )
                if( first )
                    cmake_language( CALL ${this}.data LIST:NO_SORT HELP_TEXT_${help_list} "  ${target} ${target_dots} ${line}" )
                    unset( first )
                else()
                    cmake_language( CALL ${this}.data LIST:NO_SORT HELP_TEXT_${help_list} "  ${target_spaces}${line}" )
                endif()
            endforeach()
        else()
            message( AUTHOR_WARNING "Target property HELP_TEXT not set\ntarget = \"${target}\"" )
            cmake_language( CALL ${this}.data LIST:NO_SORT HELP_TEXT_${help_list} "  ${target}" )
        endif()

        if( NOT ${target} STREQUAL ${this}.check )
            cmake_language( CALL ${this}.target check COMMAND_FILE "${CMAKE_COMMAND}" -E echo "Checking target: ${target}" )
            cmake_language( CALL ${this}.target check COMMAND_FILE "${CMAKE_COMMAND}" --build "${PROJECT_BINARY_DIR}" --config "${check_config}" --target "${target}" )
        endif()
    endforeach( target )

    # target must be created after all last data modification 
    cmake_language( CALL ${this}.data GET DATA_NAMES data_names )
    if( data_names )
        list( APPEND data_names "DATA_NAMES" )
        list( SORT data_names )
        foreach( data_name IN LISTS data_names )
            cmake_language( CALL ${this}.data GET "${data_name}" data )
            if( data )
                list( TRANSFORM data PREPEND "  " )
                list( PREPEND data "${data_name}" )
                cmake_language( CALL ${this}.target show.data
                    COMMAND_FILE_ECHO_LIST ${data}
                )
            endif()
        endforeach()
    endif()

    set( first TRUE )
    cmake_language( CALL ${this}.data GET HELP_ORDER order )
    foreach( section IN LISTS order )
        cmake_language( CALL ${this}.data GET HELP_HEAD_${section} head )
        cmake_language( CALL ${this}.data GET HELP_TEXT_${section} text )

        if( NOT head OR NOT text )
            continue()
        elseif( NOT first )
            cmake_language( CALL ${this}.target help COMMAND_FILE "${CMAKE_COMMAND}" -E echo "" )
        endif()
        unset( first )
        cmake_language( CALL ${this}.target help COMMAND_FILE_ECHO_LIST ${head} )
        cmake_language( CALL ${this}.target help COMMAND_FILE_ECHO_LIST ${text} )
    endforeach()
endfunction()

function( ${CTestRunner.FunctionName}.target_add target ... )
    string( REGEX REPLACE "\\.[a-z_]+$" "" this "${CMAKE_CURRENT_FUNCTION}" )
    if( NOT name )
        message( FATAL_ERROR "Target name not set" )
        return()
    endif()

    set( target ${this}.${name} )
    cmake_parse_arguments( PARSE_ARGV 1 arg "" "ADD_DEPENDENCY" "ADD_SOURCES" )

    if( arg_ADD_DEPENDENCY AND NOT "SkipDependencies" IN_LIST CTestRunner.Config )
        cmake_language( CALL ${this}.debug "TARGET" "Dependency... ${target} -> ${arg_ADD_DEPENDENCY}" )
        cmake_language( CALL ${this}.data "LIST" "TARGETS_DEPENDENCIES:${target}" "${arg_ADD_DEPENDENCY}" )
        add_dependencies( ${target} ${arg_ADD_DEPENDENCY} )
    endif()

    if( arg_ADD_SOURCES )
        target_sources( ${target} PRIVATE ${arg_ADD_SOURCES} )
    endif()
endfunction()

function( ${CTestRunner.FunctionName}.target name ... )
    string( REGEX REPLACE "\\.[a-z]+$" "" this "${CMAKE_CURRENT_FUNCTION}" )
    if( NOT name )
        message( FATAL_ERROR "Target name not set" )
        return()
    endif()

    set( mode_0 COMMAND_FILE_SYMBOLIC )
    set( mode_1 )
    set( mode_N CMAKE CTEST COMMAND_FILE COMMAND_FILE_ECHO_LIST )
    set( mode_X COMMAND_FILE COMMAND_FILE_ECHO_LIST )
    set( properties HELP_TEXT HELP_LIST )
    set( args_0 ADD_ONCE )
    set( args_1 ADD_DEPENDENCY ${properties} )
    set( args_N ADD_SOURCES )
    cmake_parse_arguments( PARSE_ARGV 1 arg "${mode_0};${args_0}" "${mode_1};${args_1}" "${mode_N};${args_N}" )

    set( target ${this}.${name} )
    set( target_file "${CMAKE_CURRENT_BINARY_DIR}/${target}.content")
    if( arg_ADD_ONCE AND TARGET ${target} )
        cmake_language( CALL ${this}.target_add ${name}
            ADD_DEPENDENCY ${arg_ADD_DEPENDENCY}
            ADD_SOURCES ${arg_ADD_SOURCES}
        )
        return()
    endif()

    unset( mode_current )
    foreach( mode_guess IN LISTS mode_0 mode_1 mode_N )
        if( arg_${mode_guess} )
            if( mode_current )
                message( FATAL_ERROR "More than one mode used\n${mode_current} + ${mode_guess}" )
            endif()
            set( mode_current "${mode_guess}" )
        endif()
    endforeach()

    if( NOT TARGET ${target} AND NOT mode_current IN_LIST mode_X )
        cmake_language( CALL ${this}.debug "TARGET" "Add target... ${target} (${mode_current})" )
    endif()

    if( arg_CMAKE )
        add_custom_target( ${target} COMMAND "${CMAKE_COMMAND}" ${arg_CMAKE} VERBATIM )
    elseif( arg_CTEST )
        if( CMAKE_BUILD_TYPE )
            set( build_config "${CMAKE_BUILD_TYPE}" )
        else()
            set( build_config "Release" )
        endif()
        add_custom_target( ${target} COMMAND "${CMAKE_CTEST_COMMAND}" --build-config ${build_config} --output-on-failure ${arg_CTEST} )
    elseif( arg_COMMAND_FILE_SYMBOLIC )
        add_custom_target( ${target} DEPENDS "${target_file}" )
        add_custom_command( OUTPUT "${target_file}" COMMENT "" VERBATIM )
        set_property( SOURCE "${target_file}" PROPERTY SYMBOLIC TRUE )
    elseif( arg_COMMAND_FILE )
        cmake_language( CALL "${CMAKE_CURRENT_FUNCTION}" ${name} COMMAND_FILE_SYMBOLIC ADD_ONCE )
        add_custom_command( OUTPUT "${target_file}" APPEND COMMAND ${arg_COMMAND_FILE} )
    elseif( arg_COMMAND_FILE_ECHO_LIST )
        cmake_language( CALL "${CMAKE_CURRENT_FUNCTION}" ${name} COMMAND_FILE_SYMBOLIC ADD_ONCE )
        foreach( element IN LISTS arg_COMMAND_FILE_ECHO_LIST )
            cmake_language( CALL "${CMAKE_CURRENT_FUNCTION}" ${name} COMMAND_FILE "${CMAKE_COMMAND}" -E echo "${element}" )
        endforeach()
    else()
        set( mode_list ${mode_0} ${mode_1} ${mode_N} )
        list( SORT mode_list )
        list( JOIN mode_list ", " mode_list )
        message( FATAL_ERROR "Exactly one of following arguments must be set\n${mode_list}" )
        return()
    endif()

    cmake_language( CALL ${this}.target_add ${name}
        ADD_DEPENDENCY ${arg_ADD_DEPENDENCY}
        ADD_SOURCES ${arg_ADD_SOURCES}
    )

    if( NOT mode_current IN_LIST mode_X )
        cmake_language( CALL ${this}.debug "TARGET" "- mark target ${target}" )
        set_property( TARGET ${target} PROPERTY ${this} TRUE )
        cmake_language( CALL ${this}.data LIST TARGETS ${target} )

        cmake_language( CALL ${this}.data GET TARGETS_MAX_LENGTH targets_max_length )
        string( LENGTH "${target}" target_length )
        if( NOT targets_max_length OR target_length GREATER targets_max_length )
            cmake_language( CALL ${this}.data SET TARGETS_MAX_LENGTH ${target_length} )
        endif()

        endif()

    foreach( property IN LISTS properties)
        if( arg_${property} )
            cmake_language( CALL ${this}.debug "TARGET" "- property  ${property} = ${arg_${property}}" )
            set_property( TARGET ${target} PROPERTY ${this}.${property} "${arg_${property}}" )
        endif()
    endforeach()
endfunction()

function( ${CTestRunner.FunctionName}.label test_name label_name )
    string( REGEX REPLACE "\\.[a-z]+$" "" this "${CMAKE_CURRENT_FUNCTION}" )

    cmake_language( CALL ${this}.debug "TEST" "- label             ${this}:${label_name}" )
    set_property( TEST "${test_name}" PROPERTY LABELS "${this}:${label_name}" APPEND )

    cmake_language( CALL ${this}.data LIST LABELS "${this}:${label_name}" )

    cmake_language( CALL ${this}.target show.labels
        COMMAND_FILE_SYMBOLIC
        HELP_TEXT "Print all tests labels created by ${this}()"
        HELP_LIST "SHOW"
        ADD_ONCE
    )
endfunction()

function( ${CTestRunner.FunctionName}.data mode name value )
    string( REGEX REPLACE "\\.[a-z]+$" "" this "${CMAKE_CURRENT_FUNCTION}" )

    if( NOT TARGET ${this}.data )
        add_custom_target( ${this}.data )
        cmake_language( CALL "${CMAKE_CURRENT_FUNCTION}" LIST TARGETS ${this}.data )
        cmake_language( CALL "${CMAKE_CURRENT_FUNCTION}" LIST HELP_SKIP ${this}.data )

        cmake_language( CALL ${this}.target show.data
            COMMAND_FILE_SYMBOLIC
            HELP_TEXT "Print all collected metadata"
            HELP_LIST "SHOW"
            ADD_ONCE
        )
    endif()

    if( "${mode}" STREQUAL "GET" )
        get_property( data TARGET ${this}.data PROPERTY "${this}.${name}" )
        set( ${value} "${data}" PARENT_SCOPE )
        return()
    elseif( "${mode}" STREQUAL "SET" )
        set_property( TARGET ${this}.data PROPERTY "${this}.${name}" "${value}" )
    elseif( "${mode}" STREQUAL "LIST" )
        get_property( data TARGET ${this}.data PROPERTY "${this}.${name}" )
        list( APPEND data "${value}" )
        list( REMOVE_DUPLICATES data )
        list( SORT data )
        set_property( TARGET ${this}.data PROPERTY "${this}.${name}" "${data}" )
    elseif( "${mode}" STREQUAL "LIST:NO_SORT" )
        set_property( TARGET ${this}.data PROPERTY "${this}.${name}" "${value}" APPEND )
    else()
        message( FATAL_ERROR "Unknown data mode\nmode = \"${mode}\"" )
        return()
    endif()

    if( NOT "${name}" STREQUAL "DATA_NAMES" )
        cmake_language( CALL "${CMAKE_CURRENT_FUNCTION}" LIST DATA_NAMES "${name}" )
    endif()
endfunction()
